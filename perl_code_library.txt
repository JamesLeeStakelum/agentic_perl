
########################################################################
########################################################################
########################################################################
# Utility Functions
########################################################################
########################################################################
########################################################################

########################################################################
# LLM Interaction
########################################################################
sub call_llm {

    my ($prompt, $template, $config_file, $logs_folder) = @_;

    # Check if template is defined and not empty
    if (!defined $template || $template eq '') {$template = 'precise';}

    # Check if config_file is defined and not empty
    if (!defined $config_file || $config_file eq '') {$config_file = "openrouter_config.txt";}

    # Check if logs_folder is defined and not empty
    if (!defined $logs_folder || $logs_folder eq '') {$logs_folder = "./logs";}

    # Temp folder will always be ./temp
    my $temp_folder  = ".//temp";

    # Generate temp file name
    my @chars = ('A'..'Z', 'a'..'z', '0'..'9');
    my $random_string = "";
    for (my $i = 0; $i < 20; $i++) {$random_string .= $chars[int(rand scalar(@chars))];}

    # Create the temp directory if it doesn't exist
    unless (-d $temp_folder) {mkdir $temp_folder;}

    my $input_file  = "$temp_folder/${random_string}_input.txt";
    my $output_file = "$temp_folder/${random_string}_output.txt";

    # Create the logs directory if it doesn't exist.
    unless (-d $logs_folder) {mkdir $logs_folder;}

    # Write the prompt to the input file in UTF-8 mode.
    write_file($input_file, $prompt);

    # Build the command string to call the external LLM executable.
    my $cmd = "call_openrouter.exe --input_file $input_file --output_file $output_file --logs_folder $logs_folder --openrouter_config_file $config_file --template $template";

    # Execute the command and check for errors.
    my $system_result = system($cmd);
    if ($system_result != 0) {
        unlink $input_file, $output_file;
        return '';
    }
    
    # Read the response from the output file.
    open(my $out_fh, "<:encoding(UTF-8)", $output_file) or return '';
    my $response = do { local $/; <$out_fh> };
    close($out_fh);

    # Trim response
    $response =~ s/^\s+|\s+$//g;

    return $response;
}

########################################################################
# Trim leading and trailing whitespace from a string.
########################################################################
sub trim {
    my ($string) = @_;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}

########################################################################
# Write content to a file in UTF-8 mode.
########################################################################
sub write_file {

    my ($file, $content) = @_;

    $content =~ s/\r\n/\n/g;  # Convert Windows-style newlines to Unix

    if (open(my $fh, ">:encoding(UTF-8)", $file)) {
        print $fh $content;
        close($fh);
        return 1; # Indicate success
    } else {
        warn "Could not open file '$file' for writing: $!";
        return 0; # Indicate failure
    }
}

########################################################################
# Generate a random alphanumeric string of a given length (default is 20).
########################################################################
sub generate_random_string {
    my ($length) = @_;
    $length = 20 unless defined $length;
    my @chars = ('A'..'Z', 'a'..'z', '0'..'9');
    my $random_string = "";
    for (my $i = 0; $i < $length; $i++) {
        $random_string .= $chars[int(rand scalar(@chars))];
    }
    return $random_string;
}

########################################################################
# extract_text_between_tags($text, $tag, %opts)
########################################################################
#
# Extracts content from Large Language Model (LLM) responses enclosed within
# specified tags. This function is designed to be robust against common LLM
# formatting mistakes.
#
# Parameters:
#   $text (scalar): The LLM's response string.
#   $tag (scalar): The name of the tag to extract (e.g., 'answer', 'comments').
#                  Case-insensitivity is handled internally.
#   %opts (hash, optional): A hash of optional parameters to control extraction behavior.
#       strict (boolean): If set to `1`, requires both opening and closing tags.
#                         Defaults to `0` (flexible).
#
# Returns:
#   The extracted and cleaned content as a scalar string.
#   Returns an empty string ('''') if:
#     - No content for the specified tag can be robustly extracted.
#     - The `strict` option is enabled, and a perfect opening/closing tag pair is not found.
#
# Key Features:
#   - Flexible Tag Matching: Handles tags like `< answer >` or `< /answer >` by
#     normalizing whitespace. Also corrects common misspellings for 'answer' tags.
#   - LLM-Specific Cleanup: Removes `<model>...</model>` blocks and infers a missing
#     `</answer>` tag if it's followed by `<comments>` or `<thinking>` tags.
#   - Intelligent Boundary Handling: Extracts content even if only the opening or
#     closing tag is present (in flexible mode), extending to string boundaries or
#     semantic markers like `<comments>`.
#   - Optional Strict Mode: Use `strict => 1` to ensure only perfectly matched tag
#     pairs are extracted.
#
########################################################################

sub extract_text_between_tags {
    my ($text, $tag, %opts) = @_;
    my $lc_tag = lc $tag;
    my $strict_mode = $opts{strict} // 0; # Defaults to flexible extraction

    my $open_tag_canonical = "<" . $lc_tag . ">";   # The standard form for our searches
    my $close_tag_canonical = "</" . $lc_tag . ">"; # The standard form for our searches

    my $temp_text = $text; # Work on a temporary copy to allow modifications
    my $temp_text_lc;      # Will hold the lowercased, normalized version for searching

    # --- 1. Normalize tags for flexibility against LLM whitespace/misspelling mistakes ---
    # This step intelligently converts variations like "< answer >" or "< /answer >"
    # into their canonical forms "<answer>" and "</answer>" before any searching.
    # It also handles optional attributes within the tags.
    $temp_text =~ s{<\s*\Q$lc_tag\E\s*[^>]*>}{$open_tag_canonical}gi;
    $temp_text =~ s{<\s*\/\s*\Q$lc_tag\E\s*[^>]*>}{$close_tag_canonical}gi;

    if ($lc_tag eq 'answer') {
        # Specific normalization for common 'answer' tag misspellings (with optional attributes)
        $temp_text =~ s/<answe?r?[^>]*>/<answer>/gi;
        $temp_text =~ s/<\/answe?r?[^>]*>/<\/answer>/gi;
        $temp_text =~ s/<answers?>/<answer>/gi;
        $temp_text =~ s/<\/answers?>/<\/answer>/gi;
    }

    # Always generate the lowercased version of the *normalized* text for case-insensitive searching
    $temp_text_lc = lc $temp_text;

    # --- 2. LLM-Specific Special Handling for <answer> tag ---
    if ($lc_tag eq 'answer') {
        # a) Robustly remove <model> </model> blocks:
        # Normalize <model> tags themselves first, for maximum reliability (with optional attributes)
        $temp_text =~ s{<\s*model\s*[^>]*>}{<model>}gi;
        $temp_text =~ s{<\s*\/\s*model\s*[^>]*>}{</model>}gi;
        $temp_text_lc = lc $temp_text; # Re-lowercase after model normalization

        my $start = index($temp_text_lc, '<model>');
        while ($start >= 0) {
            my $end = index($temp_text_lc, '</model>', $start);
            last if $end < 0; # No matching closing </model> found

            # Remove the <model> block from both the content and the search copy
            # +8 accounts for the length of '</model>'
            substr($temp_text, $start, $end - $start + 8, '');
            substr($temp_text_lc, $start, $end - $start + 8, '');

            # Search for the next <model> from the current position (as string length changed)
            $start = index($temp_text_lc, '<model>', $start);
        }

        # b) Imply </answer> if <comments> or <thinking> tag is found and </answer> is missing:
        # Normalize <comments> and <thinking> tags as well, for robustness (with optional attributes)
        $temp_text =~ s{<\s*comments\s*[^>]*>}{<comments>}gi;
        $temp_text =~ s{<\s*thinking\s*[^>]*>}{<thinking>}gi;
        $temp_text_lc = lc $temp_text; # Re-lowercase after these normalizations

        if (index($temp_text_lc, $close_tag_canonical) < 0) { # If </answer> is still not found
            my $cpos = index($temp_text_lc, '<comments>');
            my $tpos = index($temp_text_lc, '<thinking>');
            my $boundary_pos = -1;

            # Find the earliest of <comments> or <thinking>
            if ($cpos >= 0 && ($tpos < 0 || $cpos < $tpos)) {
                $boundary_pos = $cpos;
            } elsif ($tpos >= 0) {
                $boundary_pos = $tpos;
            }

            if ($boundary_pos >= 0) {
                # Inject the missing </answer> right before the detected boundary tag
                substr($temp_text, $boundary_pos, 0, $close_tag_canonical);
                $temp_text_lc = lc $temp_text; # Crucial: refresh after injection
            }
        }
    }

    # --- 3. Intelligent Content Extraction Logic ---
    # Find the positions of the canonical (and now normalized) open/close tags
    my $s_pos = index($temp_text_lc, $open_tag_canonical);
    my $e_pos = index($temp_text_lc, $close_tag_canonical);
    my $extracted_content;

    if ($s_pos >= 0 && $e_pos >= 0 && $e_pos > $s_pos) {
        # Case 1: Perfect match - Both tags found and in correct order
        $extracted_content = substr(
            $temp_text,
            $s_pos + length($open_tag_canonical),
            $e_pos - ($s_pos + length($open_tag_canonical))
        );
    } elsif ($strict_mode) {
        # Case 2: Strict mode is active, but a perfect match was NOT found.
        # Immediately return empty content as per strict requirement.
        $extracted_content = "";
    } elsif ($s_pos >= 0 && $e_pos < 0) {
        # Case 3: Flexible mode - Only opening tag found.
        # Content is extracted from the tag to the end of the string.
        # For 'answer' tag, stop at other known semantic boundary tags if they appear later.
        $extracted_content = substr($temp_text, $s_pos + length($open_tag_canonical));
        if ($lc_tag eq 'answer') {
            # Define specific boundary tags where an answer should semantically end
            my @boundaries = (
                '<comments>', '<thinking>', '<model>',
                # Add other common end-of-answer markers if your LLM uses them, e.g., "\n\n---"
            );
            my $min_boundary_pos = length($extracted_content);
            for my $boundary_tag (@boundaries) {
                my $pos = index(lc($extracted_content), $boundary_tag);
                if ($pos >= 0 && $pos < $min_boundary_pos) {
                    $min_boundary_pos = $pos;
                }
            }
            $extracted_content = substr($extracted_content, 0, $min_boundary_pos);
        }
    } elsif ($s_pos < 0 && $e_pos >= 0) {
        # Case 4: Flexible mode - Only closing tag found.
        # Content is extracted from the beginning of the string up to the tag.
        $extracted_content = substr($temp_text, 0, $e_pos);
    } else {
        # Case 5: Neither tag found at all (or tags were reversed in an unrecoverable way).
        # This is the clear signal that no content for the requested tag was present.
        $extracted_content = "";
    }

    # --- 4. Post-Extraction Cleanup ---
    # Trim any leading or trailing whitespace from the extracted content
    $extracted_content =~ s/^\s+|\s+$//g;

    # Remove non-ASCII characters (as per your original requirement)
    $extracted_content = remove_non_ascii($extracted_content);

    return $extracted_content;
}

########################################################################
# Read text file of unknown encoding
########################################################################
#
# Reads a text file with robust encoding detection and error handling.
# This function is designed for maximum reliability when dealing with files
# from unknown sources or with mixed encodings.
#
# Returns:
#   The decoded file content as a single Perl string with Unix-style (\n)
#   line endings.
#   Returns an empty string ('') if the file cannot be opened or is empty.
#
########################################################################

# This subroutine requires the core Encode module for robust text decoding.
use Encode qw(decode);

sub read_file {

    my ($filename) = @_;

    # --- 1. Read the entire file in raw binary mode ---
    # This prevents Perl's I/O layers from interfering with encoding detection.
    open my $fh, '<:raw', $filename or return ""; # Return empty string on open failure
    my $raw_content = do { local $/; <$fh> };
    close $fh;

    return "" unless length $raw_content; # Return empty string if file is empty

    my $content;
    my $detected_encoding = '';

    # --- 2. Proactive BOM Handling (Best Practice) ---
    # Check for and strip Byte Order Marks from the raw bytes *before* decoding.
    # This is more reliable and prevents the BOM from causing decoding errors.
    if (substr($raw_content, 0, 3) eq "\xEF\xBB\xBF") {
        $detected_encoding = 'UTF-8';
        $raw_content = substr($raw_content, 3); # Strip UTF-8 BOM
    }
    elsif (substr($raw_content, 0, 2) eq "\xFF\xFE") {
        $detected_encoding = 'UTF-16LE';
        $raw_content = substr($raw_content, 2); # Strip UTF-16LE BOM
    }
    elsif (substr($raw_content, 0, 2) eq "\xFE\xFF") {
        $detected_encoding = 'UTF-16BE';
        $raw_content = substr($raw_content, 2); # Strip UTF-16BE BOM
    }

    # --- 3. Attempt to Decode with a Prioritized List (Strict) ---
    my @encodings_to_try;
    if ($detected_encoding) {
        # If the BOM gave us the encoding, trust it and try it exclusively.
        @encodings_to_try = ($detected_encoding);
    } else {
        # Otherwise, build a prioritized list of common encodings to try.
        # This implements your "successively try different encodings" logic.
        @encodings_to_try = (
            'UTF-8', 'Windows-1252', 'ISO-8859-1', 'ASCII'
            # Add other less common encodings here if needed, e.g.:
            # 'UTF-16LE', 'UTF-16BE', 'Shift-JIS', 'EUC-JP'
        );
    }

    foreach my $encoding (@encodings_to_try) {
        eval {
            # Attempt a strict decoding. If it encounters an invalid byte
            # sequence for that encoding, it will fail (croak).
            $content = decode($encoding, $raw_content, Encode::FB_CROAK);
        };
        if (!$@) {
            # Success! A valid decoding was found.
            last;
        }
    }

    # --- 4. Resilient Final Fallback ---
    if (!defined $content) {
        # If all strict decoding attempts failed, this is the final safety net.
        # It decodes as UTF-8 but replaces any invalid characters instead of
        # failing. This prevents the "time bomb" of returning raw bytes.
        $content = decode('UTF-8', $raw_content);
    }

    # --- 5. Final Line Ending Normalization ---
    # Ensures consistent Unix-style line endings for all downstream processing.
    $content =~ s/\r\n?/\n/g;

    return $content;
}

########################################################################
# Create temporary folder if it does not exist
########################################################################
sub create_temp_folder {
    my $folder = ".//temp";
    unless (-d $folder) {
        mkdir $folder or die "Failed to create temp folder '$folder': $!";
    }
}

########################################################################
# Extracting list that may be either structured or unstructured from text.
########################################################################
sub extract_list_from_text {

    my ($big_text, $extraction_type, $target_description, $chunk_size, $max_loops) = @_;
    $chunk_size ||= 10;  # default chunk size

    # Normalize extraction type
    $extraction_type = ($extraction_type eq 'explicit_list')
                     ? 'explicit_list'
                     : 'organic_orthogonal';

    my @extracted_list;
    my $last_item = '';
    my $all_done   = 0;
    my $iterations = 0;
   

    unless ($max_loops > 0) {$max_loops = 20;}  # maximum number of passes

    while (!$all_done && $iterations++ < $max_loops) {

print "Iteration: $iterations\n";

        # Build prompt
        my $prompt = build_prompt(
            type               => $extraction_type,
            text               => $big_text,
            target_description => $target_description,
            chunk_size         => $chunk_size,
            extracted_so_far   => \@extracted_list,
            last_item          => $last_item,
        );

        # Call the LLM
        my $response = call_llm($prompt);
        my $answer   = extract_text_between_tags($response, 'answer');

        # Stop if no new answer
        unless (defined $answer && $answer ne '') {
            $all_done = 1;
            last;
        }

        # Auto-detect splitting mode
        my @new_items;
        if ($answer =~ /\n{2,}/) {
            # multi-line blocks
            @new_items = split /\n{2,}/, $answer;
        } else {
            # single-line items
            @new_items = split /\n/, $answer;
        }

        # Trim and filter out empty lines
        @new_items = grep { /\S/ }
                     map  { s/^\s+|\s+$//gr }
                     @new_items;

        # Append and update last_item
        push @extracted_list, @new_items;
        $last_item = $new_items[-1] // $last_item;
    }

    if ($iterations >= $max_loops) {
        warn "extract_list_from_text: reached $max_loops iterations without finishing\n";
    }

    # Join with double newlines if multi-line blocks were used, else single newline
    my $joined;
    if (grep { /\n/ } @extracted_list) {
        $joined = join "\n\n", @extracted_list;
    } else {
        $joined = join "\n",    @extracted_list;
    }

    return $joined;
}

# Helper to assemble the prompt
sub build_prompt {
    my %args = @_;
    my $chunks = join "\n\n", @{ $args{extracted_so_far} };

    my $common_header = <<"END_HDR";
Here is the text to analyze:

## BEGIN SOURCE TEXT ##
$args{text}
## END SOURCE TEXT ##

TASK: Extract "$args{target_description}" in groups of $args{chunk_size}.

**Avoid duplicate information by doing gap analysis against existing information previously extracted**
We're using an iterative approach to find and extract information. In this current iteration, I need you to report only the information you haven't previously reported. It's VERY important that you avoid extracting information that's already previously been extracted. So, to avoid duplicates, or near duplicates where the information is essentially the same but worded differently, you must compare any information you find against what has already been extracted in a previous iteration.

Here (below) is a list of what's already been extracted:

## BEGIN EXTRACTED ##
$chunks
## END EXTRACTED ##



Last item: "$args{last_item}"

END_HDR

    if ($args{type} eq 'organic_orthogonal') {

        return <<"END_PROMPT";
You are an expert at identifying non-duplicating, orthogonal items. When considering adding a new item to your list of items, always compare to the 'already extracted' list, and do gap analysis, to verify the item is new before including it in your output.

$common_header
Continue after the last item and return the next batch of orthogonal points, avoiding any duplicates (or near-duplicates that use different wording but express essentially the same information).
Use one block per paragraph or line as appropriate. Wrap the full list in <answer>...</answer>.
Empty <answer></answer> means there are no more finds.
END_PROMPT

    } else {
        return <<"END_PROMPT";
You are an expert at extracting ordered lists exactly as they appear.

$common_header
Continue after the last item and return the *next* $args{chunk_size} items,
one block per paragraph or line as appropriate. Wrap the full list in <answer>...</answer>.
Empty <answer> means no more.
END_PROMPT

    }
}
 


sub clear_temp_folder {

    # Folder to inspect
    my $folder = "./temp";

    my $threshold = $_[0];
    unless ($threshold > 0) {$threshold = 1}

    # Current time
    my $now = time();

    # Open the folder
    opendir(my $dh, $folder) or die "Cannot open directory '$folder': $!";

    # Loop through each file in the folder
    while (my $file = readdir($dh)) {
        # Skip special entries '.' and '..'
        next if $file eq '.' or $file eq '..';

        # Construct the full file path
        my $file_path = "$folder/$file";

        # Skip directories
        next if -d $file_path;

        # Get file creation or change time
        my $ctime = (stat($file_path))[10];  # Index 10 is ctime (inode change time or creation time)

        # Check if the file is older than the threshold
        if (($now - $ctime) > $threshold) {
            # Print the name of the file before deleting
            #print "Deleting old file: $file_path\n";
            # Delete the file
            unlink $file_path or warn "Could not delete '$file_path': $!";
        }
    }

    # Close the folder
    closedir($dh);

    return;

}

########################################################################
# Remove non-ascii such as emoticons, curly quotes, emdash.
# Retain accented charcters such as umlauts, and typographical symbols.
########################################################################
sub remove_non_ascii {

    my $text = shift;

    # Remove emoticons
    $text =~ s/[\x{1F600}-\x{1F64F}\x{1F300}-\x{1F5FF}\x{1F680}-\x{1F6FF}\x{2600}-\x{26FF}\x{2700}-\x{27BF}]//g;

    # Normalize quotes and dashes, ellipsis, and replace non-ASCII
    $text =~ s/[\x{201C}\x{201D}\x{00AB}\x{00BB}]/"/g;
    $text =~ s/[\x{2018}\x{2019}]/'/g;
    $text =~ s/[\x{2013}\x{2014}]/--/g;
    $text =~ s/\x{2026}/.../g;

    # Remove zero-width characters
    $text =~ s/[\x{200B}\x{200C}\x{200D}\x{FEFF}]//g; 

    # REMOVED: The line that replaced all other non-ASCII with '?'
    #$text =~ s/[^\x00-\x7F]/?/g;

    # Remove "Other" Unicode characters, EXCEPT line feed, carriage return, tab,
    # accented characters, non-Latin scripts, common typographical symbols, 
    # currency symbols, and language-specific punctuation.
    # This specifically targets control characters, format characters,
    # unassigned code points, private use characters, and surrogates.
    #$text =~ s/(?![\r\n])\p{C}//g;
    $text =~ s/(?![\r\n\t])\p{C}//g;

    # Normalize line endings: convert CRLF and CR to LF
    $text =~ s/\r\n?/\n/g;

    return $text;
}

########################################################################
# Hill climbing to explore several candidates
########################################################################

=pod

### Process Overview: The `hill_climbing` Subroutine

The `hill_climbing` subroutine is a sophisticated, self-correcting algorithm designed to iteratively improve the quality of an LLM-generated response. It formalizes the agentic pillar of **Iterative Improvement** by creating a cycle of generation, critique, and judgment, ensuring the final output is significantly more refined than a single-shot attempt.

The process can be broken down into four distinct phases:

#### Phase 1: Setup and Intelligent Initialization

Before any candidates are generated, the subroutine prepares the environment:

1.  **Argument Handling:** It begins by unpacking its core inputs: a target folder, a base prompt for generating candidates (`$candidate_prompt`), a judge count, the maximum number of iterations, and an optional file containing evaluation criteria.
2.  **Dynamic Criteria Generation:** The script checks if evaluation criteria were provided.
    * If a criteria file exists, it's used.
    * If not, the script intelligently prompts an LLM to act as an expert, showing it the `$candidate_prompt` and asking it to generate a specific, relevant set of evaluation criteria for the task. This ensures the subsequent critique and judging steps are tailored to the specific problem.
    * A hardcoded, generic instruction is used only as a last resort if the LLM fails to generate criteria.

#### Phase 2: Generating the Initial Candidate

With the setup complete, the process is bootstrapped:

1.  The subroutine makes its first call to the LLM using the unmodified `$candidate_prompt`.
2.  The response from this initial call is extracted and saved as `best.txt` in the specified folder. This first version automatically becomes the initial "Best Solution" to be improved upon.

#### Phase 3: The Iterative Refinement Loop

The script now enters its main loop, which runs for a specified number of iterations (`$max_iteration - 1`) to progressively enhance the "Best Solution". Each cycle within the loop consists of three crucial steps that embody the **"Second Mind"** reliability pattern.

* **(A) The Critique Phase (Second Mind)**
    * The current `Best Solution` is presented to an LLM "critic".
    * This critic is given full context: the original `$candidate_prompt`, the `Best Solution` itself, and the `Evaluation Criteria`.
    * Its task is to provide concrete, actionable `advice` on how the solution can be improved. This step directly implements the "Second Mind" pillar by having an LLM reflect on and critique an existing output.

* **(B) The New Candidate Generation Phase**
    * A new generative prompt is constructed. Critically, this is done via **substitution**, not just concatenation.
    * The process starts with the original `$candidate_prompt` template.
    * It finds a placeholder (e.g., `{previous_solution}`) within that template and **replaces** it with the full text of the current `Best Solution`.
    * Finally, the `advice` from the critique phase is appended to this prompt, guiding the LLM to generate a new and improved candidate solution.

* **(C) The Judgment Phase**
    * The newly generated `candidate` is pitted against the current `Best Solution`.
    * The `judge_voting` helper function is called to manage this comparison.
    * A "panel" of LLM judges is convened (equal to `$judge_count`). Each judge is shown both versions, the original prompt for context, and the `Evaluation Criteria`, and must vote for the better version by returning '1' or '2'.
    * The votes are tallied to determine a winner by majority.

* **(D) The Promotion/Update Phase**
    * If the `new_candidate` wins the majority vote (returns '2'), it is promoted. The `best.txt` file is overwritten with the content of the superior candidate.
    * If the current `Best Solution` wins or the vote is a tie, the new candidate is discarded, and the loop proceeds to the next iteration using the existing champion.

This refinement cycle is visualized below:

```
START
  |
  +--> Generate Initial Candidate --> Set as "Best Solution"
  |
  +--> BEGIN LOOP (for max_iteration - 1 times)
  |      |
  |      +--> (A) Critique "Best Solution" --> Get "Advice"
  |      |
  |      +--> (B) Generate "New Candidate" (using Best Solution + Advice)
  |      |
  |      +--> (C) Judges Compare "Best" vs. "New"
  |      |
  |      +--> (D) IF "New" is better THEN
  |      |       |
  |      |       +--> "New Candidate" becomes the new "Best Solution"
  |      |
  |      +--> END LOOP
  |
DONE (Final "Best Solution" is in best.txt)
```

#### Phase 4: Completion

After the loop finishes, the `hill_climbing` subroutine concludes. It does not return a value directly; its final, most-refined output remains persistent in the `best.txt` file within the specified working folder.

=cut

sub hill_climbing {

    my ($folder, $candidate_prompt, $judge_count, $max_iteration, $evaluation_criteria_file) = @_;
   
    my $best;
    my $response;
    my $candidate;
    my $judgement;
    my $dir;
    my $find;
    my $i;
    my $critique_prompt;
    my $advice;
    my $prompt;
    my $evaluation_criteria;
    my $initial_probes;
    my $answer;

    if ($evaluation_criteria_file ne '') {$evaluation_criteria = read_file($evaluation_criteria_file);} else {$evaluation_criteria = '';}

    my $prompt_template = $candidate_prompt;

    my $previous_solution = '';

    # Provide defaults
    unless ($judge_count > 0)   {$judge_count = 1} 
    unless ($max_iteration > 0) {$max_iteration = 3}

    # hard-coded for test purposes
    #$judge_count = 3;

    # Provide evaluation criteria if we don't have one
    #if ($evaluation_criteria eq '') {$evaluation_criteria = "Refer to the instructions and background information relevant to the task that was performed to produce the candidate solutions, and use that information to evaluate the candidates based on which one provides the best results in regards to the instructions.";}

# Provide evaluation criteria if we don't have one
if ($evaluation_criteria eq '') {

    # Create a meta-prompt to ask the LLM to generate criteria, following all design guidelines.
    my $meta_prompt = <<"END";
**About The Task**
You are an expert at creating evaluation standards. Below, you will find a prompt that is used to command a Large Language Model to perform a task.

Your job is to carefully read and understand the prompt and then devise a concise set of evaluation criteria that can be used to judge the quality, accuracy, and overall effectiveness of the output generated by the prompt.

**Original Prompt to Analyze**
########################################################################
# Begin Original Prompt
########################################################################

$candidate_prompt

########################################################################
# End Original Prompt
########################################################################

**Your Assignment**
Based on the prompt above, generate a clear, bulleted list of evaluation criteria. The criteria should be suitable for a human or an AI judge to use when comparing two different responses generated from the original prompt.

**Output Format**
Your response MUST be structured using the following tags:
- The primary list of evaluation criteria MUST be enclosed within <answer>...</answer> tags. 
- Any additional comments, notes, or rationale MUST be placed within <comments>...</comments> tags.

**Formatting Rules**
- Do not use emoticons.
- Use plain, straight quotes (' and ") and apostrophes only. 
- Use double-hyphens (--) instead of emdashes (—) or en-dashes (–). 
END

    print "-> Evaluation criteria not found. Asking LLM to generate it...\n";
    my $criteria_response = call_llm($meta_prompt);
    $evaluation_criteria = extract_text_between_tags($criteria_response, 'answer');

    # Fallback to the generic default ONLY if the LLM fails to generate criteria
    if ($evaluation_criteria eq '') {
        print "-> LLM failed to generate criteria. Using generic default.\n";
        $evaluation_criteria = "Refer to the instructions and background information relevant to the task that was performed to produce the candidate solutions, and use that information to evaluate the candidates based on which one provides the best results in regards to the instructions.";
    } else {
        print "-> Successfully generated new evaluation criteria.\n";
    }
}


    # Add leading ./ if missing
    if (substr($folder, 0, 1) ne '.') {$folder = './' . $folder}

    ensure_directory($folder);

    # About ten percent of the search attempts should be initial probes, but avoid too many initial probes
    $initial_probes = int($max_iteration * 0.1) + 1;
    if ($initial_probes > 5) {$initial_probes = 5}

    # Look for a previous best solution.   
    #if (-e "$folder/best.txt") {$previous_solution = read_file("$folder/best.txt")} else {$previous_solution = 'There is not yet a previous solution against which to compare.';}
    #$prompt = $prompt_template;
    #$find = '{previous_solution}';
    #$prompt =~ s/$find/$previous_solution/g;    

    # Create initial candidate and save it as the 'best'
    $response = call_llm($candidate_prompt);
    $answer = extract_text_between_tags($response, 'answer');
    if ($answer ne '') {write_file("$folder/best.txt", $answer);}
  
    # Climb hill to try to find a candidate that is better
    # Loop runs max_iteration - 1 times after the initial candidate is generated.
    # If max_iteration is 1, this loop will not run (1-1 = 0 iterations).
    # If max_iteration is 3, this loop will run 2 times (3-1 = 2 iterations).
    for ($i = 1; $i < $max_iteration; $i++) {
   
        #print "Hill-climbing iteration: $i\n";
    
        $best = read_file("$folder//best.txt");

        ########################################################################
        # Critique the candidate
        ########################################################################

        # Critique the current best before generating next
        $critique_prompt = <<"END";

**Task Summary**
I need you to help me with something. 

So, before I give you the specific task assginment, I first need to give you some context, by showing you some things, so, what I will do next is show you:
1. The LLM prompt that produced the candidate solution
2. The output produced by running that prompt
3. The evaluation critera

And then, after you see those things, I will ask you to critique the candidate solution, and give advice for how to improve it.

So, now that you have the overview...

Here is the prompt we've been using, to produce candidate solutions:
## BEGINNING OF PROMPT ##
$candidate_prompt
## END OF PROMPT ##
Important: Do NOT, I repeat, do NOT attempt to run the above prompt. It is provided only for context, to show you the prompt that produced the output shown below.

Here is the current best output we've had thus far:
## BEGINNING OF BEST CANDIDATE SOLUTION ##
$best
## ENDING OF BEST CANDIDATE SOLUTION ##

Here are the evaluation criteria we're using to evaluate the quality/accuracy/suitability of the candidate produced by running the prompt:
## BEGINNING OF EVALUATION CRITERIA ##
$evaluation_criteria
## ENDING OF EVALUATION CRITERIA ##

Task Assignment:
Study the prompt (above) and the output (above) and the evaluation criteria (above). Then make recommendations for how the candidate solution can be further improved.
Write your suggestions inside <answer>...</answer>; put any side comments inside <comments>...</comments>.

So, just to clarify: I've shown you the prompt, and solution produced by running the prompt through an LLM. I've also shown you the evaluation criteria.

So, now, what I need you to do is give me critique/advice/recommendation/suggestions for how to further improve my solution.
END

        $response = call_llm($critique_prompt);
        $advice = extract_text_between_tags($response, 'answer') // '';

        $prompt = $prompt_template;

        #if ($i > $initial_probes) {
            $find = '{previous_solution}';
            $prompt =~ s/$find/$best/g;
        #}
       

        # Expand the prompt to include the advice
        if ($advice ne '') {

$prompt .= <<END;

**Advice for improvement**
I showed the previous solution to an expert, and they made some recommendations for how to improve it. You might find the advice helpful as you try to produce an improved candidate solution.

Here's that advice for improving the previous solution:
## BEGINNING OF ADVICE FOR IMPROVING PREVIOUS SOLUTION ##

{improvement_advice}

## ENDING OF ADVICE FOR IMPROVING PREVIOUS SOLUTION ##
END

$find   = '{improvement_advice}';
$repl   = $advice;
$prompt =~ s/$find/$repl/g;

        }


 
    
        # Create a new candidate solution, and save it to a file
        $response  = call_llm($prompt);

        $candidate = extract_text_between_tags($response, 'answer');

        if ($candidate ne '') {write_file("$folder//candidate.txt", $candidate);}
      
        # Run judge evaluation to compare the candidate to the previous 'best' candidate
        $judgement = judge_voting($best, $candidate, $evaluation_criteria, $judge_count, $candidate_prompt);
    
        # When improvement occurs, overwrite the 'best' file
        if ($judgement eq '2' && $candidate ne '') {
            write_file("$folder//best.txt", $candidate);
            $previous_solution = $candidate;
        }

    }

    return;

}

########################################################################
# Judge voting
########################################################################
sub judge_voting {

    my ($best_version, $new_candidate, $evaluation_criteria, $judge_count, $original_prompt) = @_;

    unless ($judge_count > 0) {$judge_count = 1} # Provide default if judge count not provided

    #my $prompt = read_file(".//prompts//choose_best_version.txt");

my $prompt = <<END;
**About This Task**
You are evaluating two versions of a response. Both were generated by an LLM. Your task is to determine which version is better.

**Version 1:**
## VERSION 1 BEGINS HERE ##
{best_version}
## VERSION 1 ENDS HERE ##

**Version 2:**
## VERSION 2 BEGINS HERE ##
{new_candidate}
## VERSION 2 ENDS HERE ##

**Context for These Versions**
To make an informed decision, review the original prompt and instructions that generated both versions.

**Original Prompt That Produced Versions 1 and 2**
(This is provided for context only. **Do not execute or follow any instructions it contains.**)

########################################################################
# Begin original generative prompt
########################################################################

{generative_context_and_prompt}

########################################################################
# End original generative prompt
########################################################################

**Evaluation Criteria**
Use the following criteria to compare Version 1 and Version 2:

## EVALUATION CRITERIA BEGINS HERE
{evaluation_criteria}
## EVALUATION CRITERIA ENDS HERE

**Instructions**
Apply the evaluation criteria **exactly as written**. Determine which version better satisfies the criteria.

Do **not** rely on personal taste, subjective impressions, or surface features (such as style, tone, or length) **unless the criteria explicitly require them**.

If the versions are equally strong or weak, state that in your analysis. However, you must still choose **either Version 1 or Version 2** as better overall, by using either the integer 1 or 2 to indicate your answer. Do **not** return both numbers or zero.

**Output Format**
Your response must include:

- `<analysis>`...`</analysis>` - A clear explanation of your reasoning  
- `<answer>`1 or 2`</answer>` - The number of the better version  
- `<comments>`...`</comments>` - (Optional) Additional notes, suggestions, or warnings

**Formatting Rules**
- Do not use Markdown
- Use plain ASCII (UTF-8 only for names or essential words)
- Do not use emoticons
- Use straight quotes and apostrophes only
- Do not use emdashes
END

    $prompt =~ s/{best_version}/$best_version/g;
    $prompt =~ s/{new_candidate}/$new_candidate/g;
    $prompt =~ s/{evaluation_criteria}/$evaluation_criteria/g;
    $prompt =~ s/{generative_context_and_prompt}/$original_prompt/g;

    my %total_hash = ();

    $total_hash{'1'} = 0;
    $total_hash{'2'} = 0;

    for (1 .. $judge_count) {

        my $response = call_llm($prompt);

        my $vote = extract_text_between_tags($response, 'answer');

        if (($vote ne '1') && ($vote ne '2')) {$vote = '1'}

        if ($vote eq '1') {$total_hash{'1'}++}
        if ($vote eq '2') {$total_hash{'2'}++}

    }

    my $return_value = '1';

    if ($total_hash{'2'} > $total_hash{'1'}) {$return_value = '2'} else {$return_value = '1'}

    return $return_value;

}

########################################################################
# Ensures that the given directory exists, creating any intermediate
# directories as needed.
########################################################################
use File::Path qw(make_path);

sub ensure_directory {
    my ($dir) = @_;

    # Print current working directory for debugging
    #print "Current working directory: ", Cwd::cwd(), "\n";

    # Remove trailing slash(es)
    $dir =~ s{[\\/]+$}{};

    # If it already exists, do nothing
    return if -d $dir;

    # Otherwise, create the directory tree
    eval {
        make_path($dir);
    };
    if ($@) {
        die "Could not create directory '$dir': $@";
    }
}

########################################################################
# Function to merge files from a directory
########################################################################
sub merge_files_in_directory {

    my ($directory, $output_file, $separator) = @_;

    my $merged_content = "";

    # 1. Open the directory
    opendir(my $dh, $directory)
        or warn "Could not open directory '$directory': $!\n" and return;

    # 2. Read the files in the directory
    my @files = readdir($dh);
    closedir($dh);

    # 3. Filter out special entries and directories
    @files = grep { !/^\.\.?$/ && -f "$directory/$_" } @files;

    # 4. Process each file
    foreach my $filename (@files) {
        my $filepath = "$directory/$filename";

        print "  Reading file: $filepath\n";

        my $file_content = read_file($filepath); # Use the read_file function

        if (defined $file_content) {
            $merged_content .= $file_content . $separator;
        } else {
            warn "   Failed to read file: $filepath\n"; #warn instead of die
        }
    }

    # 5. Write the merged content to the output file
    if (length $merged_content) { # Only write if there's content
        write_file($output_file, $merged_content)
            or warn "   Could not write to output file '$output_file': $!\n";
        print "  Merged content written to: $output_file\n";
    } else {
        warn "   No content to write to $output_file\n";
    }
}

########################################################################
########################################################################
#                         UNIVERSAL LLM PIPELINE 
########################################################################
########################################################################

########################################################################
# This block documents the multi-stage workflow driven by a simple config
# string. Paste it into your code file to explain the process.
########################################################################

# 1) parse_config_string($config_string)
#    -> Reads key:value lines from the config string
#    -> Trims whitespace, skips blank or comment lines
#    -> Builds a hashref of all settings (prompt_file, data_type, etc.)

# 2) validate_config($cfg, \@required_keys)
#    -> Ensures required keys are present and non-empty
#    -> Checks data_type is one of text, list, none
#    -> Checks output_format is one of text, list, nested_list
#    -> Verifies max_iterations is a positive integer (warns if >100)

# 3) read_file($cfg->{prompt_file})
#    -> Loads the LLM prompt template from disk

# 4) choose_primary_input_path($cfg)
#    -> If data_type == list and list_input_file exists, use that
#    -> Otherwise use placeholder_1_file
#    -> If data_type == none, skip this step

# 5) read_file($primary_path)
#    -> Reads the main input blob (story seed, code spec, etc.)

# 6) extract_list (optional)
#    -> If extract_list && data_type == text, run extract_list_from_text
#    -> Converts freeform text into a list blob and sets data_type -> list

# 7) prepare_prompt($template, $cfg)
#    -> Substitutes placeholders:
#         - {placeholder_1_name} <- contents of placeholder_1_file
#         - {placeholder_2_name} <- contents of placeholder_2_file
#         - {primer}             <- primer_file
#         - {criteria}           <- criteria_file
#    -> Returns the fully-formed LLM prompt

# 8) burst_input($primary_text, $cfg)
#    -> If data_type == list, splits on list_marker:
#         - empty_lines (blank lines), one_line_per_item, or custom marker
#    -> Otherwise returns the whole text as a single-element list

# 9) process_chunk(%args)
#    -> For each chunk:
#         - Inject the chunk into the prompt at {list_member_placeholder_name}
#         - Create folder $project_folder/$task_folder/item_N
#         - Run hill_climbing(folder, prompt, 1, max_iterations, criteria_file)
#         - Read back best.txt as the revised chunk

# 10) assemble_output(\@revised_chunks, $cfg)
#    -> Loops through revised chunks in order
#    -> Optionally prepends:
#         - GLOBAL_ID: N    (if global_id_name is set)
#         - Section label or first-line heading
#    -> Joins chunks with blank lines into one big output string

# 11) write_file($cfg->{output_file}, $final_output)
#    -> Writes the assembled output to disk (UTF-8, Unix newlines)

################################################################################
#                               PASS MODES
#
# - generate-pass    : initial burst -> LLM -> merge
# - review-pass      : global \"find issues\" audit (outputs list of IDs)
# - patch-pass       : reprocess only flagged IDs and reassemble
# - polish-pass      : re-run LLM on all chunks for broad improvement
# - consistency-pass : cluster-level fixes for inter-chunk coherence
# - validate-pass    : external checks (linters, tests, validators)
# - finalize-pass    : strip metadata, format cleanup, package output
################################################################################

################################################################################
# Pipelines can be created, such as:
#
# Basic codegen:
# generate-pass ? validate-pass ? finalize-pass
#
# Iterative improvement:
# generate-pass ? review-pass ? patch-pass ? polish-pass ? validate-pass ? finalize-pass
#
# Deep coherence check:
# generate-pass ? consistency-pass ? validate-pass ? finalize-pass
################################################################################


################################################################################
# Section for generate_pass and its helpers
################################################################################

###############################################
# Top-level driver: generate_pass
###############################################
sub generate_pass {
    my ($config_string) = @_;

    # 1) Parse the config into a hashref
    my $cfg = parse_config_string($config_string);

    # 2) Validate required config keys
    validate_config($cfg, [
        'prompt_file',
        'data_type',
        'max_iterations',
        'project_folder',
        'task_folder',
        'output_file'
    ]);

    # 3) Read the LLM prompt template
    my $prompt_template = read_file($cfg->{prompt_file});
    die "Cannot read prompt_file '$cfg->{prompt_file}'\n"
        unless defined $prompt_template && length $prompt_template;

    # 4) Choose and read the primary input (or none)
    my $primary_text = '';
    if ($cfg->{data_type} ne 'none') {
        my $primary_path = choose_primary_input_path($cfg);
        $primary_text = read_file($primary_path);
        die "Cannot read primary input '$primary_path'\n"
            unless defined $primary_text;
    }

    # 5) Optionally extract list from text
    if ($cfg->{extract_list} && $cfg->{data_type} eq 'text') {
        my $extracted = extract_list_from_text(
            $primary_text,
            $cfg->{extract_method} // 'organic_orthogonal',
            $cfg->{extract_topic}  // 'topical categories',
            $cfg->{extract_limit}  // 10
        );
        if (defined $extracted && $extracted ne '') {
            $primary_text         = $extracted;
            $cfg->{data_type}     = 'list';
        }
    }

    # 6) Prepare the prompt (substitute placeholders)
    my $prepared_prompt = prepare_prompt($prompt_template, $cfg);

    # 7) Burst into chunks (handles list/text/none)
    my @chunks = burst_input($primary_text, $cfg);
    die "No chunks to process\n" unless @chunks;

    # 8) Process each chunk with LLM + hill-climbing
    my @revised_chunks;
    for my $index (0 .. $#chunks) {
        my $raw_chunk   = $chunks[$index];
        my $serial      = $index + 1;
        my $revised     = process_chunk(
            raw_chunk       => $raw_chunk,
            prompt_template => $prepared_prompt,
            config          => $cfg,
            serial_number   => $serial,
        );
        die "Processing failed for chunk $serial\n" unless length $revised;
        push @revised_chunks, $revised;
    }

    # 9) Assemble all chunks into final output
    #my $final_output = assemble_output(\@revised_chunks, $cfg);
    my $final_output = assemble_output(\@revised_chunks, \@chunks, $cfg);

    # 10) Write final output file
    write_file($cfg->{output_file}, $final_output)
        or die "Failed to write output_file '$cfg->{output_file}'\n";

    print "generate-pass complete ? $cfg->{output_file}\n";
}

###############################################
# parse_config_string
###############################################
sub parse_config_string {
    my ($text) = @_;
    my %config;
    for my $raw_line (split /\r?\n/, $text) {
        my $line = trim($raw_line);
        next if $line eq '';
        next if substr($line,0,1) eq '#';
        my ($key, $value) = split /:/, $line, 2;
        $key   = trim($key);
        $value = defined $value ? trim($value) : '';
        $config{$key} = $value;
    }
    return \%config;
}

###############################################
# validate_config
###############################################
sub validate_config {
    my ($cfg, $required_keys) = @_;
    for my $key (@$required_keys) {
        die "Missing required config key '$key'\n"
            unless exists $cfg->{$key} && defined $cfg->{$key} && $cfg->{$key} ne '';
    }
    if ($cfg->{max_iterations} !~ /^\d+$/ || $cfg->{max_iterations} <= 0) {
        die "Invalid max_iterations: must be a positive integer\n";
    }
    if ($cfg->{max_iterations} > 100) {
        warn "max_iterations is very large (>100)\n";
    }
    unless ($cfg->{data_type} =~ /^(?:text|list|none)$/) {
        die "Invalid data_type '$cfg->{data_type}'\n";
    }
    unless ($cfg->{output_format} =~ /^(?:text|list|nested_list)$/) {
        die "Invalid output_format '$cfg->{output_format}'\n";
    }
}

###############################################
# choose_primary_input_path
###############################################
sub choose_primary_input_path {
    my ($cfg) = @_;
    if ($cfg->{data_type} eq 'list'
        && $cfg->{list_input_file}
        && -e $cfg->{list_input_file}
    ) {
        return $cfg->{list_input_file};
    }
    return $cfg->{placeholder_1_file};
}

###############################################
# prepare_prompt
###############################################
sub prepare_prompt {

    my ($template, $cfg) = @_;
    my $prompt = $template;

    # Primary placeholder
    if (my $name1 = $cfg->{placeholder_1_name}) {
        my $file1 = $cfg->{placeholder_1_file} // '';
        if ($file1 && -e $file1) {
            my $txt1    = read_file($file1);
            my $pattern = quotemeta '{' . $name1 . '}';
            $prompt =~ s/$pattern/$txt1/g;
        }
    }
    # Secondary placeholder
    if (my $name2 = $cfg->{placeholder_2_name}) {
        my $file2 = $cfg->{placeholder_2_file} // '';
        if ($file2 && -e $file2) {
            my $txt2    = read_file($file2);
            my $pattern = quotemeta '{' . $name2 . '}';
            $prompt =~ s/$pattern/$txt2/g;
        }
    }
    # Primer
    if (my $pf = $cfg->{primer_file}) {
        if (-e $pf) {
            my $primer = read_file($pf);
            $prompt     =~ s/\{primer\}/$primer/g;
        }
    }
    # Criteria
    if (my $cf = $cfg->{criteria_file}) {
        if (-e $cf) {
            my $crit = read_file($cf);
            $prompt  =~ s/\{evaluation_criteria\}/$crit/g;
        }
    }
    return $prompt;
}

###############################################
# burst_input
###############################################
sub burst_input {
    my ($text, $cfg) = @_;
    return ($text) if $cfg->{data_type} ne 'list';
    my $marker = $cfg->{list_marker} // 'empty_lines';
    if ($marker eq 'empty_lines') {
        return grep { /\S/ } split /\n\s*\n+/, $text;
    }
    elsif ($marker eq 'one_line_per_item') {
        return split /\r?\n/, $text;
    }
    else {
        my $esc = quotemeta $marker;
        return grep { /\S/ } split /(?=$esc)/, $text;
    }
}

###############################################
# process_chunk
###############################################
sub process_chunk {
    my (%args) = @_;
    my $raw_chunk       = $args{raw_chunk};
    my $prompt_template = $args{prompt_template};
    my $cfg             = $args{config};
    my $serial          = $args{serial_number};

    # Insert chunk into prompt
    my $prompt = $prompt_template;
    if (my $ph = $cfg->{list_member_placeholder_name}) {
        my $pat = quotemeta '{'.$ph.'}';
        $prompt =~ s/$pat/$raw_chunk/g;
    }

    # Ensure output folder exists
    my $folder = join '/', $cfg->{project_folder}, $cfg->{task_folder}, "item_$serial";
    ensure_directory($folder);

    # Run LLM hill_climbing
    hill_climbing(
        $folder,
        $prompt,
        1,
        $cfg->{max_iterations},
        $cfg->{criteria_file}
    );

    # Read result
    my $result = read_file("$folder/best.txt");
    return defined $result ? $result : '';
}

###############################################
# assemble_output
###############################################
sub assemble_output {

  my ($results_ref, $raw_ref, $cfg) = @_;
  my @revised = @{ $results_ref };
  my @raw     = @{ $raw_ref };
  my $out     = "";

  # (1) build the raw combined output
  for my $i (0..$#revised) {
    my $name = $raw[$i] // "";
    my $body = $revised[$i] // "";

    # optional section label
    if (my $label = $cfg->{section_label}) {
      $label =~ s/:$//;    # drop trailing colon
      $out .= "$label: $name\n";
    }

    $out .= $body;
    $out .= "\n\n";
  }

  # (2) insert global IDs before each beat-number chunk, with single blank lines between
  my $gid        = $cfg->{global_id_name}  // "";
  my $sub_marker = $cfg->{sublist_marker} // "";

  if ($gid ne "" && $sub_marker ne "") {
    # normalize marker text (no trailing colon) and build case-insensitive regex
    (my $base = $sub_marker) =~ s/:$//;
    my $marker_re = qr{
      ^\s*                   # start of line + optional whitespace
      (?i:\Q$base\E)         # marker, case-insensitive
      :?                     # optional colon
      \s*                    # optional trailing whitespace
    }xm;

    # split on each occurrence of marker at line-start
    my @chunks = split /(?=$marker_re)/m, $out;
    my $n      = 1;
    my $new    = "";

    for my $i (0..$#chunks) {
      my $c = $chunks[$i];
      next unless $c =~ /\S/;      # skip empty fragments

      # prepend the global ID line
      $new .= "$gid: $n\n";
      $new .= $c;

      # add exactly one blank line _between_ chunks (not after the last)
      $new .= "\n" if $i < $#chunks;

      $n++;
    }

    $out = $new;
  }

  return $out;
}

################################################################################
# Section for review_pass and its helpers
################################################################################

sub review_pass {
    my ($config_string) = @_;

    my $cfg = parse_config_string($config_string);
    validate_config($cfg, [
      'review_prompt_file',
      'data_type',
      'project_folder',
      'task_folder',
      'input_file',
      'review_output_file',
      'list_member_placeholder_name',
    ]);

    my $template = read_file($cfg->{review_prompt_file});
    die "Cannot read review_prompt_file\n" unless length $template;

    my $full = read_file($cfg->{input_file});
    die "Cannot read input_file\n" unless defined $full;

    my @chunks = burst_input($full, $cfg);
    die "No chunks to review\n" unless @chunks;

    my @blocks;
    for my $i (0 .. $#chunks) {
        my $id    = $i + 1;
        my $chunk = $chunks[$i];

        # build prompt
        my $prompt = $template;
        $prompt =~ s/\{item_number\}/$id/g;
        if (my $ph = $cfg->{list_member_placeholder_name}) {
            my $pat = quotemeta('{'.$ph.'}');
            $prompt =~ s/$pat/$chunk/g;
        }

        # call LLM
        my $reply = hill_climbing_inline(
            prompt         => $prompt,
            max_iterations => $cfg->{max_iterations},
            criteria_file  => $cfg->{criteria_file},
        );

        # split on the delimiter, keep only actionable blocks
        for my $block ( split /\n---\s*\n/, $reply ) {
            next unless $block =~ /ID:\s*\Q$id\E/;
            # pick out severity
            if ($block =~ /severity:\s*none\b/) {
                # skip chunks with no issues
                next;
            }
            push @blocks, $block;
        }
    }

    my $out = join("\n---\n", @blocks) . "\n";
    write_file($cfg->{review_output_file}, $out)
      or die "Cannot write review_output_file\n";

    print "review-pass complete ? $cfg->{review_output_file}\n";
}






################################################################################
# Section for polish_pass and its helpers
################################################################################



###############################################
# Top-level driver: polish_pass (ID-aware)
###############################################
sub polish_pass {
    my ($config_string) = @_;

    # 1) Parse config
    my $cfg = parse_config_string($config_string);
    validate_config($cfg, [
      'polish_prompt_file',
      'input_file',
      'output_file',
      'project_folder',
      'task_folder',
      'global_id_name',               # e.g. "GLOBAL_ID"
      'list_member_placeholder_name', # e.g. "item"
      'max_iterations',
    ]);

    # 2) Read templates & input
    my $template = read_file($cfg->{polish_prompt_file});
    die "Missing polish_prompt_file\n" unless length $template;
    my $full_text = read_file($cfg->{input_file});
    die "Missing input_file\n"     unless defined $full_text;

    # 3) Burst on GLOBAL_ID into %chunks and @order
    my ($chunks_ref, $order_ref) = burst_output($full_text, $cfg->{global_id_name});
    die "No chunks found to polish\n" unless @$order_ref;

    # 4) Polish each chunk by ID
    my %polished;
    for my $id (@$order_ref) {
        my $raw = $chunks_ref->{$id};

        # build prompt
        my $prompt = $template;
        # inject raw chunk
        if (my $ph = $cfg->{list_member_placeholder_name}) {
            my $pat = quotemeta('{'.$ph.'}');
            $prompt =~ s/$pat/$raw/g;
        }

        # run hill_climbing
        my $folder = join '/', $cfg->{project_folder}, $cfg->{task_folder}, "polish_$id";
        ensure_directory($folder);
        hill_climbing(
            $folder,
            $prompt,
            1,
            $cfg->{max_iterations},
            $cfg->{criteria_file},
        );

        my $result = read_file("$folder/best.txt") // '';
        die "Polish failed for chunk $id\n" unless length $result;
        $polished{$id} = $result;
    }

    # 5) Merge polished chunks back into one text
    my $output = merge_chunks($order_ref, \%polished, "\n\n");

    # 6) Write final output
    write_file($cfg->{output_file}, $output)
      or die "Failed to write polished output\n";

    print "polish-pass complete ? $cfg->{output_file}\n";
}




###############################################
# burst_output (case?insensitive, trimmed IDs)
###############################################
sub burst_output {
    my ($text, $id_key) = @_;

    # Build a regex that matches lines like 'GLOBAL_ID:  12' ignoring case & spaces
    my $marker_re = qr/^\s*\Q$id_key\E\s*:\s*(\S+)\s*$/im;

    # Split on any line that begins with the id_key (in any case)
    my @parts = split /(?=^\s*\Q$id_key\E\s*:)/im, $text;

    my %chunks;
    my @order;

    for my $part (@parts) {
        # Extract the first line s ID and the rest as its body
        if ($part =~ $marker_re) {
            my $raw_id = $1;
            my $uc_id  = uc $raw_id;        # normalize to uppercase
            $part =~ s/^\s*//;              # trim leading whitespace
            $chunks{$uc_id} = $part;        # include the ID line in the body
            push @order, $uc_id;
        }
    }

    return (\%chunks, \@order);
}

###############################################
# merge_chunks (preserve original ID line exactly)
###############################################
sub merge_chunks {
    my ($order_ref, $chunks_ref, $joiner) = @_;

    my @out;
    for my $id_uc (@$order_ref) {
        # Each stored chunk already begins with its original ID line,
        # so just pull it back out:
        my $chunk_text = $chunks_ref->{$id_uc};
        push @out, $chunk_text;
    }

    # Rejoin with your chosen spacer
    return join $joiner, @out;
}





################################################################################
# Section for patch_pass and its helpers
################################################################################

# Top-level driver: patch_pass
sub patch_pass {
    my ($config_string) = @_;

    # 1) Parse config
    my $cfg = parse_config_string($config_string);
    validate_config($cfg, [
      'patch_prompt_file',           # prompt asking to apply fixes
      'input_file',                  # original assembled text
      'review_output_file',          # review-pass output
      'output_file',                 # where to write patched result
      'project_folder',
      'task_folder',
      'global_id_name',              # e.g. "GLOBAL_ID"
      'list_member_placeholder_name',# e.g. "item"
      'max_iterations',
    ]);

    # 2) Read prompt and files
    my $template = read_file($cfg->{patch_prompt_file});
    die "Missing patch_prompt_file" unless length $template;
    my $full_text = read_file($cfg->{input_file});
    die "Missing input_file"     unless defined $full_text;
    my $reviews   = read_file($cfg->{review_output_file});
    die "Missing review_output_file" unless defined $reviews;

    # 3) Burst original on IDs
    my ($chunks_ref, $order_ref) = burst_output($full_text, $cfg->{global_id_name});

    # 4) Parse review blocks into a hash of arrays by ID
    my %to_fix;
    for my $block ( split /\n---\s*\n/, $reviews ) {
        next unless $block =~ /^ID:\s*(\S+)/m;
        my $id = uc $1;
        push @{ $to_fix{$id} }, $block;
    }

    # 5) For each ID with fixes, re-run patch prompt
    for my $id (@$order_ref) {
        next unless exists $to_fix{$id};
        my $raw = $chunks_ref->{$id};

        # build prompt: include all review blocks for this ID
        my $prompt = $template;
        # insert raw chunk
        if (my $ph = $cfg->{list_member_placeholder_name}) {
            my $pat = quotemeta('{'.$ph.'}');
            $prompt =~ s/$pat/$raw/g;
        }
        # insert fixes list placeholder
        if ($prompt =~ /\{fixes\}/) {
            my $fix_text = join "\n---\n", @{ $to_fix{$id} };
            $prompt =~ s/\{fixes\}/$fix_text/g;
        }

        # run hill_climbing to apply patches
        my $folder = join '/', $cfg->{project_folder}, $cfg->{task_folder}, "patch_$id";
        ensure_directory($folder);
        hill_climbing(
            $folder,
            $prompt,
            1,
            $cfg->{max_iterations},
            $cfg->{criteria_file},
        );

        my $result = read_file("$folder/best.txt") // '';
        die "Patch failed for chunk $id" unless length $result;
        $chunks_ref->{$id} = $result;
    }

    # 6) Merge back
    my $output = merge_chunks($order_ref, $chunks_ref, "\n\n");
    write_file($cfg->{output_file}, $output)
      or die "Failed to write patched output\n";

    print "patch-pass complete -> $cfg->{output_file}\n";
}





sub consistency_pass {
  my ($cfg_str) = @_;
  my $cfg = parse_config_string($cfg_str);
  validate_config($cfg, [
    'consistency_prompt_file',
    'input_file',
    'output_file',
    'global_id_name',
    'project_folder',
    'task_folder',
  ]);

  # 1) Read your consistency prompt template
  my $tmpl = read_file($cfg->{consistency_prompt_file});

  # 2) Read the full text
  my $full = read_file($cfg->{input_file});

  # 3) (Optionally) burst on GLOBAL_ID if you want to operate per-chunk,
  #    or just send the entire text in one go.
  #    Here we do it all at once:
  ensure_directory("$cfg->{project_folder}/$cfg->{task_folder}/consistency");
  hill_climbing(
    "$cfg->{project_folder}/$cfg->{task_folder}/consistency",
    $tmpl =~ s/\{text\}/$full/r,   # inject full text into {text}
    1,
    $cfg->{max_iterations},
    $cfg->{criteria_file},
  );

  # 4) Write out best.txt to output_file
  my $out = read_file("$cfg->{project_folder}/$cfg->{task_folder}/consistency/best.txt");
  write_file($cfg->{output_file}, $out);
  print "consistency-pass complete ? $cfg->{output_file}\n";
}


sub validate_pass {
  my ($cfg_str) = @_;
  my $cfg = parse_config_string($cfg_str);
  validate_config($cfg, [
    'input_file',     # e.g. your final script or document
    'validation_cmd', # e.g. "perl -c" or "pytest"
    'validation_report_file',
  ]);

  my $in  = $cfg->{input_file};
  my $cmd = "$cfg->{validation_cmd} $in 2>&1";
  my $report = `$cmd`;               # capture stdout/stderr

  write_file($cfg->{validation_report_file}, $report);
  print "validate-pass complete ? $cfg->{validation_report_file}\n";
}


sub finalize_pass {
  my ($cfg_str) = @_;
  my $cfg = parse_config_string($cfg_str);
  validate_config($cfg, [
    'input_file',
    'output_file',
    'finalize_cmd',   # optional script to package/output
  ]);

  my $text = read_file($cfg->{input_file});
  # Example: remove all GLOBAL_ID lines
  $text =~ s/^\s*\Q$cfg->{global_id_name}\E\s*:\s*\d+\s*$\n//mg;

  # Optionally run an external finalize command
  if (my $cmd = $cfg->{finalize_cmd}) {
    my $tmp_in = "$cfg->{project_folder}/tmp_finalize_input.txt";
    write_file($tmp_in, $text);
    system("$cmd $tmp_in $cfg->{output_file}");
  }
  else {
    write_file($cfg->{output_file}, $text);
  }

  print "finalize-pass complete ? $cfg->{output_file}\n";
}


sub process_accumulation_prompt {

    # Takes the full prompt template (which should include the source text
    # or tell the LLM how to refer to it) as the first argument.
    my $prompt_template = $_[0];

    # Takes the maximum number of iterations as the second argument.
    my $max_iterations = $_[1];

    # Initializes an empty string to store the accumulated responses.
    # (Spelling: accumlated -> accumulated)
    my $accumulated_response = ''; # Corrected spelling

    # Sets a default for max_iterations if an invalid or no value is provided.
    unless ($max_iterations > 0) {$max_iterations = 5}

    # Loops for the specified number of iterations.
    # (Variable name: $max_iteration -> $max_iterations)
    for (my $i = 1; $i <= $max_iterations; $i++) { # Corrected variable name

        # Creates a fresh copy of the prompt template for each iteration. This is good.
        my $prompt = $prompt_template; # Added 'my' for lexical scope

        # Defines the placeholder string to find.
        my $find = "{accumulated_text}";
        # Defines what to replace it with (the currently accumulated response).
        my $replace = $accumulated_response;

        # Substitutes the placeholder with the accumulated content.
        # For a fixed simple string like "{accumulated_text}", this direct substitution is usually fine.
        # For more complex placeholders, using \Q in the regex (s/\Q$find\E/$replace/g) is safer.
        $prompt =~ s/$find/$replace/g;

        # Calls your LLM function (from perl_library.pl).
        # Assumes call_llm is in scope and correctly handles its own optional parameters
        # if only $prompt is passed. Your library function does this.
        my $response = call_llm($prompt); 

        # Extracts the content from the <answer> tag using your library function.
        # Assumes extract_text_between_tags is in scope.
        my $answer = extract_text_between_tags($response, 'answer');
        # It's good practice to ensure $answer is a string, even if empty, if extraction fails.
        $answer = "" unless defined $answer;


        # Appends the new answer directly to the accumulated string.
        # Consider adding a separator here if $answer chunks are multi-line blocks
        # and you want them distinctly separated in the final output.
        # For example:
        # if ($accumulated_response ne '' && $answer ne '') {
        #     $accumulated_response .= "\n\n"; # Or just "\n"
        # }
        $accumulated_response .= $answer;


#print "Answer:\n$answer\n\n";



        # OPTIONAL: Add a condition to stop early if the LLM returns an empty answer,
        # which usually signals it has no more new information to add.
        # Your prompt should instruct the LLM to do this.
        if ($answer eq '') {
            #print "[INFO] Iteration $i: LLM returned empty answer, stopping accumulation.\n";
            last; # Exits the loop
        }
        #print "[INFO] Iteration $i: Accumulated length " . length($accumulated_response) . "\n";

    }

    # Returns the final string containing all concatenated answers.
    return $accumulated_response;
}

1;





