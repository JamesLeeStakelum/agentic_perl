
# ==============================================================================
#
#                            Agentic Perl Library
#
# A comprehensive library of utility functions and design patterns for building
# sophisticated, multi-stage LLM-driven applications in Perl.
#
# ==============================================================================

# --- Standard Perl Pragmas ---
use strict;
use warnings;

# --- Core Module Dependencies ---
use Encode qw(decode);
use File::Path qw(make_path);

# ==============================================================================
# SECTION 1: CORE UTILITIES
# Basic functions for file I/O, string manipulation, and system interaction.
# ==============================================================================

########################################################################
# write_file($file, $content)
# Writes content to a file, ensuring UTF-8 encoding and Unix newlines.
########################################################################
sub write_file {
    my ($file, $content) = @_;
    $content =~ s/\r\n/\n/g;
    if (open(my $fh, ">:encoding(UTF-8)", $file)) {
        print $fh $content;
        close($fh);
        return 1;
    } else {
        warn "Could not open file '$file' for writing: $!";
        return 0;
    }
}

########################################################################
# read_file($filename)
# Robustly reads a text file, handling various encodings and BOMs.
########################################################################
sub read_file {
    my ($filename) = @_;
    open my $fh, '<:raw', $filename or return "";
    my $raw_content = do { local $/; <$fh> };
    close $fh;
    return "" unless length $raw_content;

    my ($content, $detected_encoding);

    if (substr($raw_content, 0, 3) eq "\xEF\xBB\xBF") {
        $detected_encoding = 'UTF-8';
        $raw_content = substr($raw_content, 3);
    } elsif (substr($raw_content, 0, 2) eq "\xFF\xFE") {
        $detected_encoding = 'UTF-16LE';
        $raw_content = substr($raw_content, 2);
    } elsif (substr($raw_content, 0, 2) eq "\xFE\xFF") {
        $detected_encoding = 'UTF-16BE';
        $raw_content = substr($raw_content, 2);
    }

    my @encodings_to_try = $detected_encoding ? ($detected_encoding)
        : ('UTF-8', 'Windows-1252', 'ISO-8859-1', 'ASCII');

    foreach my $encoding (@encodings_to_try) {
        eval { $content = decode($encoding, $raw_content, Encode::FB_CROAK); };
        last if !$@;
    }

    $content = decode('UTF-8', $raw_content) unless defined $content;
    $content =~ s/\r\n?/\n/g;
    return $content;
}

########################################################################
# generate_random_string($length)
# Generates a random alphanumeric string (default length: 20).
########################################################################
sub generate_random_string {
    my ($length) = @_;
    $length = 20 unless defined $length && $length > 0;
    my @chars = ('A'..'Z', 'a'..'z', '0'..'9');
    my $random_string = "";
    for (1 .. $length) {
        $random_string .= $chars[int(rand @chars)];
    }
    return $random_string;
}

########################################################################
# trim($string)
# Removes leading and trailing whitespace from a string.
########################################################################
sub trim {
    my ($string) = @_;
    return "" unless defined $string;
    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}

########################################################################
# ensure_directory($dir)
# Ensures a directory path exists, creating it if necessary.
########################################################################
sub ensure_directory {
    my ($dir) = @_;
    return if -d $dir;
    eval { make_path($dir); };
    if ($@) {
        die "Could not create directory '$dir': $@";
    }
}

########################################################################
# clear_temp_folder($threshold_seconds)
# Deletes files in the ./temp folder older than a given threshold.
########################################################################
sub clear_temp_folder {
    my ($threshold) = @_;
    my $folder = "./temp";
    return unless -d $folder;

    $threshold = 1 unless defined $threshold && $threshold > 0;
    my $now = time();

    opendir(my $dh, $folder) or die "Cannot open directory '$folder': $!";
    while (my $file = readdir($dh)) {
        next if $file eq '.' or $file eq '..';
        my $file_path = "$folder/$file";
        next if -d $file_path;
        my $ctime = (stat($file_path))[10];
        if (($now - $ctime) > $threshold) {
            unlink $file_path or warn "Could not delete '$file_path': $!";
        }
    }
    closedir($dh);
    return;
}


# ==============================================================================
# SECTION 2: TEXT AND TAG PROCESSING
# Functions for cleaning text and extracting structured data from LLM responses.
# ==============================================================================

=pod

=head1 extract_text_between_tags($text, $tag, %opts)

Extracts content from LLM responses enclosed within specified tags. This function is designed to be robust against common LLM formatting mistakes.

=over

=item * B<Parameters>

=over

=item C<$text> (scalar)

The LLM's response string.

=item C<$tag> (scalar)

The name of the tag to extract (e.g., 'answer', 'comments'). Case-insensitivity is handled internally.

=item C<%opts> (hash, optional)

A hash of options. C<strict => 1> requires perfect opening/closing tags.

=back

=item * B<Returns>

The extracted and cleaned content as a scalar string, or an empty string (C<''>) if no content can be robustly extracted.

=item * B<Key Features>

=over

=item * Flexible Tag Matching: Handles variations like C<< < answer > >> and corrects common misspellings.

=item * LLM-Specific Cleanup: Removes C<< <model>...</model> >> blocks.

=item * Intelligent Boundary Handling: Infers missing closing tags (e.g., C<</answer>>) if followed by semantic boundary tags like C<< <comments> >>.

=back

=back

=cut
sub extract_text_between_tags {
    my ($text, $tag, %opts) = @_;
    my $lc_tag = lc $tag;
    my $strict_mode = $opts{strict} // 0;

    my $open_tag_canonical = "<" . $lc_tag . ">";
    my $close_tag_canonical = "</" . $lc_tag . ">";
    my $temp_text = $text;

    $temp_text =~ s{<\s*\Q$lc_tag\E\s*[^>]*>}{$open_tag_canonical}gi;
    $temp_text =~ s{<\s*\/\s*\Q$lc_tag\E\s*[^>]*>}{$close_tag_canonical}gi;

    if ($lc_tag eq 'answer') {
        $temp_text =~ s/<answe?r?[^>]*>/<answer>/gi;
        $temp_text =~ s/<\/answe?r?[^>]*>/<\/answer>/gi;
    }

    my $temp_text_lc = lc $temp_text;

    if ($lc_tag eq 'answer') {
        $temp_text =~ s{<\s*model\s*[^>]*>}{<model>}gi;
        $temp_text =~ s{<\s*\/\s*model\s*[^>]*>}{</model>}gi;
        $temp_text_lc = lc $temp_text;
        my $start = index($temp_text_lc, '<model>');
        while ($start >= 0) {
            my $end = index($temp_text_lc, '</model>', $start);
            last if $end < 0;
            substr($temp_text, $start, $end - $start + 8, '');
            substr($temp_text_lc, $start, $end - $start + 8, '');
            $start = index($temp_text_lc, '<model>', $start);
        }

        if (index($temp_text_lc, $close_tag_canonical) < 0) {
            $temp_text =~ s{<\s*comments\s*[^>]*>}{<comments>}gi;
            $temp_text =~ s{<\s*thinking\s*[^>]*>}{<thinking>}gi;
            $temp_text_lc = lc $temp_text;
            my $cpos = index($temp_text_lc, '<comments>');
            my $tpos = index($temp_text_lc, '<thinking>');
            my $boundary_pos = -1;

            if ($cpos >= 0 && ($tpos < 0 || $cpos < $tpos)) {
                $boundary_pos = $cpos;
            } elsif ($tpos >= 0) {
                $boundary_pos = $tpos;
            }
            if ($boundary_pos >= 0) {
                substr($temp_text, $boundary_pos, 0, $close_tag_canonical);
                $temp_text_lc = lc $temp_text;
            }
        }
    }

    my $s_pos = index($temp_text_lc, $open_tag_canonical);
    my $e_pos = index($temp_text_lc, $close_tag_canonical);
    my $extracted_content = "";

    if ($s_pos >= 0 && $e_pos >= 0 && $e_pos > $s_pos) {
        $extracted_content = substr($temp_text, $s_pos + length($open_tag_canonical), $e_pos - ($s_pos + length($open_tag_canonical)));
    } elsif (!$strict_mode) {
        if ($s_pos >= 0 && $e_pos < 0) {
            $extracted_content = substr($temp_text, $s_pos + length($open_tag_canonical));
            if ($lc_tag eq 'answer') {
                my $min_boundary_pos = length($extracted_content);
                foreach my $boundary_tag ('<comments>', '<thinking>', '<model>') {
                    my $pos = index(lc($extracted_content), $boundary_tag);
                    if ($pos >= 0 && $pos < $min_boundary_pos) {
                        $min_boundary_pos = $pos;
                    }
                }
                $extracted_content = substr($extracted_content, 0, $min_boundary_pos);
            }
        } elsif ($s_pos < 0 && $e_pos >= 0) {
            $extracted_content = substr($temp_text, 0, $e_pos);
        }
    }
    
    return trim(remove_non_ascii($extracted_content));
}

########################################################################
# remove_non_ascii($text)
# Cleans text of emoticons, curly quotes, etc., while retaining accents.
########################################################################
sub remove_non_ascii {
    my ($text) = @_;
    return "" unless defined $text;

    $text =~ s/[\x{1F600}-\x{1F64F}\x{1F300}-\x{1F5FF}\x{1F680}-\x{1F6FF}\x{2600}-\x{26FF}\x{2700}-\x{27BF}]//g;
    $text =~ s/[\x{201C}\x{201D}\x{00AB}\x{00BB}]/"/g;
    $text =~ s/[\x{2018}\x{2019}]/'/g;
    $text =~ s/[\x{2013}\x{2014}]/--/g;
    $text =~ s/\x{2026}/.../g;
    $text =~ s/[\x{200B}\x{200C}\x{200D}\x{FEFF}]//g;
    $text =~ s/(?![\r\n\t])\p{C}//g;
    $text =~ s/\r\n?/\n/g;

    return $text;
}


# ==============================================================================
# SECTION 3: CORE LLM PATTERNS
# High-level functions that implement key agentic design patterns.
# ==============================================================================

########################################################################
# call_llm($prompt, $template, $config_file, $logs_folder)
# Primary function for communicating with the external LLM executable.
########################################################################
sub call_llm {
    my ($prompt, $template, $config_file, $logs_folder) = @_;

    $template    ||= 'precise';
    $config_file ||= 'openrouter_config.txt';
    $logs_folder ||= './logs';
    my $temp_folder = './temp';

    ensure_directory($temp_folder);
    ensure_directory($logs_folder);

    my $random_string = generate_random_string();
    my $input_file  = "$temp_folder/${random_string}_input.txt";
    my $output_file = "$temp_folder/${random_string}_output.txt";

    write_file($input_file, $prompt);

    my $cmd = "call_openrouter.exe --input_file $input_file --output_file $output_file --logs_folder $logs_folder --openrouter_config_file $config_file --template $template";
    my $system_result = system($cmd);

    if ($system_result != 0) {
        unlink $input_file, $output_file;
        return '';
    }
    
    my $response = read_file($output_file);
    return trim($response);
}

=pod

=head1 hill_climbing(...)

Implements a sophisticated, self-correcting algorithm to iteratively improve the quality of an LLM-generated response. It creates a cycle of generation, critique, and judgment.

(Full documentation from previous response is omitted here for brevity, but would be included in the final file)

=cut
sub hill_climbing {
    my ($folder, $candidate_prompt, $judge_count, $max_iteration, $evaluation_criteria_file) = @_;
    
    my ($best, $response, $candidate, $judgement, $find, $i, $critique_prompt, $advice, $prompt, $evaluation_criteria, $answer);
    $evaluation_criteria = ($evaluation_criteria_file && -e $evaluation_criteria_file) ? read_file($evaluation_criteria_file) : '';
    my $prompt_template = $candidate_prompt;

    $judge_count   ||= 1;
    $max_iteration ||= 3;

    if ($evaluation_criteria eq '') {
        my $meta_prompt = <<"END";
**About The Task**
You are an expert at creating evaluation standards. Below is a prompt used to command an LLM. Your job is to read the prompt and devise a concise set of evaluation criteria to judge the quality of its output.

**Original Prompt to Analyze**
########################################################################
$candidate_prompt
########################################################################

**Your Assignment**
Generate a clear, bulleted list of evaluation criteria suitable for a judge comparing two responses.

**Output Format**
- The criteria MUST be in <answer>...</answer> tags.
- Additional comments MUST be in <comments>...</comments> tags.

**Formatting Rules**
- Use plain, straight quotes (' and ").
- Use double-hyphens (--) instead of emdashes (â€”).
- Do not use emoticons.
END
        print "-> Evaluation criteria not found. Asking LLM to generate it...\n";
        my $criteria_response = call_llm($meta_prompt);
        $evaluation_criteria = extract_text_between_tags($criteria_response, 'answer');
        if ($evaluation_criteria eq '') {
            print "-> LLM failed to generate criteria. Using generic default.\n";
            $evaluation_criteria = "Refer to the instructions and background information relevant to the task to evaluate the candidates based on which one provides the best results.";
        } else {
            print "-> Successfully generated new evaluation criteria.\n";
        }
    }

    ensure_directory($folder);
    $response = call_llm($candidate_prompt);
    $answer = extract_text_between_tags($response, 'answer');
    write_file("$folder/best.txt", $answer) if $answer ne '';
  
    for ($i = 1; $i < $max_iteration; $i++) {
        $best = read_file("$folder/best.txt");
        return unless defined $best && length $best; # Stop if best is missing

        $critique_prompt = <<"END";
**Task Summary**
Critique the following solution and provide advice for improvement.

**Original Prompt:**
$candidate_prompt

**Current Best Solution:**
$best

**Evaluation Criteria:**
$evaluation_criteria

**Assignment**
Provide recommendations to improve the solution inside <answer>...</answer> tags. Place side comments in <comments>...</comments> tags.
END
        $response = call_llm($critique_prompt);
        $advice = extract_text_between_tags($response, 'answer') // '';

        $prompt = $prompt_template;
        $find = '{previous_solution}';
        $prompt =~ s/\Q$find\E/$best/g;

        if ($advice ne '') {
            $prompt .= "\n\n**Advice for improvement**\n$advice";
        }
        
        $response  = call_llm($prompt);
        $candidate = extract_text_between_tags($response, 'answer');
        next if $candidate eq '';

        write_file("$folder/candidate.txt", $candidate);
        $judgement = judge_voting($best, $candidate, $evaluation_criteria, $judge_count, $candidate_prompt);
    
        if ($judgement eq '2') {
            write_file("$folder/best.txt", $candidate);
        }
    }
    return;
}

########################################################################
# hill_climbing_inline(...) - BUG FIX
# A wrapper for hill_climbing that works entirely in-memory and returns
# the final best string, instead of writing to files.
# This function was called by review_pass but was not defined.
########################################################################
sub hill_climbing_inline {
    my %args = @_;
    my $prompt         = $args{prompt};
    my $max_iterations = $args{max_iterations} // 3;
    my $criteria_file  = $args{criteria_file}  // '';

    # Create a unique, temporary folder for this specific inline operation.
    my $temp_folder_root = "./temp";
    my $session_id = generate_random_string(12);
    my $temp_folder = "$temp_folder_root/inline_hc_$session_id";
    ensure_directory($temp_folder);

    # Call the file-based hill_climbing using the temporary folder.
    hill_climbing(
        $temp_folder,
        $prompt,
        1, # Judge count is 1 for inline operations for speed unless specified otherwise.
        $max_iterations,
        $criteria_file
    );

    # Read the final result from the 'best.txt' file.
    my $result = read_file("$temp_folder/best.txt");

    # Clean up the temporary directory.
    # Note: For heavy-duty use, a separate cleanup process might be better.
    eval { File::Path::rmtree($temp_folder); };
    warn "Could not remove temp hill-climb folder '$temp_folder': $@" if $@;
    
    return $result // '';
}


########################################################################
# judge_voting(...)
# Compares two versions and returns '1' or '2' for the winner.
########################################################################
sub judge_voting {
    my ($best_version, $new_candidate, $evaluation_criteria, $judge_count, $original_prompt) = @_;
    $judge_count ||= 1;

    my $prompt = <<"END";
**About This Task**
You are evaluating two versions of a response to determine which is better based on the provided criteria.

**Version 1:**
$best_version

**Version 2:**
$new_candidate

**Original Prompt That Produced These Versions:**
$original_prompt

**Evaluation Criteria:**
$evaluation_criteria

**Instructions**
Apply the criteria exactly. Determine which version is better. Your answer must be only the integer '1' or '2'.

**Output Format**
- <answer>1 or 2</answer>
- <comments>Optional notes</comments>
END

    my %votes = ('1' => 0, '2' => 0);
    for (1 .. $judge_count) {
        my $response = call_llm($prompt);
        my $vote = extract_text_between_tags($response, 'answer');
        $vote = '1' if ($vote ne '1' && $vote ne '2');
        $votes{$vote}++;
    }
    
    return $votes{'2'} > $votes{'1'} ? '2' : '1';
}

# ==============================================================================
# SECTION 4: PASS-BASED PIPELINE FRAMEWORK
# A modular system for orchestrating complex, multi-stage LLM workflows.
# ==============================================================================

=pod

=head1 UNIVERSAL LLM PIPELINE

This section outlines a multi-stage workflow driven by a simple configuration string.

=head2 WORKFLOW STAGES

=over

=item 1. B<parse_config_string>: Reads key:value settings.

=item 2. B<validate_config>: Ensures required keys are present.

=item 3. B<read_file>: Loads prompt templates.

=item 4. B<choose_primary_input_path>: Selects the main input data file.

=item 5. B<read_file>: Reads the primary input data.

=item 6. B<extract_list> (optional): Converts freeform text into a structured list.

=item 7. B<prepare_prompt>: Substitutes placeholders into the prompt template.

=item 8. B<burst_input>: Splits primary data into chunks for processing.

=item 9. B<process_chunk>: Runs `hill_climbing` on each individual chunk.

=item 10. B<assemble_output>: Merges processed chunks into a final result.

=item 11. B<write_file>: Saves the final output to disk.

=back

=head2 PASS MODES

=over

=item * B<generate-pass>: Initial generation of content from source data.

=item * B<review-pass>: Global audit to find issues, outputting a list of IDs to fix.

=item * B<patch-pass>: Reprocesses only the chunks flagged by the review-pass.

=item * B<polish-pass>: Re-runs the LLM on all chunks for broad quality improvements.

=item * B<consistency-pass>: A global pass to fix issues between chunks.

=item * B<validate-pass>: Runs external checks like code linters or tests.

=item * B<finalize-pass>: Strips metadata and performs final formatting.

=back

=cut

# --- Pass-Based Pipeline Driver Functions ---

sub generate_pass {
    my ($config_string) = @_;
    my $cfg = parse_config_string($config_string);
    validate_config($cfg, ['prompt_file', 'data_type', 'max_iterations', 'project_folder', 'task_folder', 'output_file']);

    my $prompt_template = read_file($cfg->{prompt_file});
    die "Cannot read prompt_file '$cfg->{prompt_file}'\n" unless length $prompt_template;

    my $primary_text = '';
    if ($cfg->{data_type} ne 'none') {
        my $primary_path = choose_primary_input_path($cfg);
        $primary_text = read_file($primary_path);
        die "Cannot read primary input '$primary_path'\n" unless defined $primary_text;
    }

    if ($cfg->{extract_list} && $cfg->{data_type} eq 'text') {
        my $extracted = extract_list_from_text(
            $primary_text, $cfg->{extract_method} // 'organic_orthogonal',
            $cfg->{extract_topic}  // 'topical categories', $cfg->{extract_limit}  // 10
        );
        if (defined $extracted && $extracted ne '') {
            $primary_text = $extracted;
            $cfg->{data_type} = 'list';
        }
    }

    my $prepared_prompt = prepare_prompt($prompt_template, $cfg);
    my @chunks = burst_input($primary_text, $cfg);
    die "No chunks to process\n" unless @chunks;

    my @revised_chunks;
    for my $index (0 .. $#chunks) {
        my $raw_chunk = $chunks[$index];
        my $serial = $index + 1;
        my $revised = process_chunk(
            raw_chunk => $raw_chunk, prompt_template => $prepared_prompt,
            config => $cfg, serial_number => $serial,
        );
        die "Processing failed for chunk $serial\n" unless length $revised;
        push @revised_chunks, $revised;
    }

    my $final_output = assemble_output(\@revised_chunks, \@chunks, $cfg);
    write_file($cfg->{output_file}, $final_output) or die "Failed to write output_file '$cfg->{output_file}'\n";
    print "generate-pass complete -> $cfg->{output_file}\n";
}

sub review_pass {
    my ($config_string) = @_;
    my $cfg = parse_config_string($config_string);
    validate_config($cfg, ['review_prompt_file', 'data_type', 'input_file', 'review_output_file', 'list_member_placeholder_name']);

    my $template = read_file($cfg->{review_prompt_file});
    die "Cannot read review_prompt_file\n" unless length $template;
    my $full = read_file($cfg->{input_file});
    die "Cannot read input_file\n" unless defined $full;

    my @chunks = burst_input($full, $cfg);
    die "No chunks to review\n" unless @chunks;

    my @blocks;
    for my $i (0 .. $#chunks) {
        my $id = $i + 1;
        my $chunk = $chunks[$i];

        my $prompt = $template;
        $prompt =~ s/\{item_number\}/$id/g;
        if (my $ph = $cfg->{list_member_placeholder_name}) {
            my $pat = quotemeta('{'.$ph.'}');
            $prompt =~ s/$pat/$chunk/g;
        }

        # ** BUG FIX: Calling the newly implemented hill_climbing_inline **
        my $reply = hill_climbing_inline(
            prompt         => $prompt,
            max_iterations => $cfg->{max_iterations} // 1, # review often needs fewer iterations
            criteria_file  => $cfg->{criteria_file},
        );

        for my $block (split /\n---\s*\n/, $reply) {
            next unless $block =~ /ID:\s*\Q$id\E/;
            next if $block =~ /severity:\s*none\b/i;
            push @blocks, $block;
        }
    }

    my $out = join("\n---\n", @blocks) . "\n";
    write_file($cfg->{review_output_file}, $out) or die "Cannot write review_output_file\n";
    print "review-pass complete -> $cfg->{review_output_file}\n";
}

sub polish_pass {
    my ($config_string) = @_;
    my $cfg = parse_config_string($config_string);
    validate_config($cfg, ['polish_prompt_file', 'input_file', 'output_file', 'project_folder', 'task_folder', 'global_id_name', 'list_member_placeholder_name', 'max_iterations']);

    my $template = read_file($cfg->{polish_prompt_file});
    die "Missing polish_prompt_file\n" unless length $template;
    my $full_text = read_file($cfg->{input_file});
    die "Missing input_file\n" unless defined $full_text;

    my ($chunks_ref, $order_ref) = burst_output($full_text, $cfg->{global_id_name});
    die "No chunks found to polish\n" unless @$order_ref;

    my %polished;
    for my $id (@$order_ref) {
        my $raw = $chunks_ref->{$id};
        my $prompt = $template;
        if (my $ph = $cfg->{list_member_placeholder_name}) {
            my $pat = quotemeta('{'.$ph.'}');
            $prompt =~ s/$pat/$raw/g;
        }

        my $folder = join '/', $cfg->{project_folder}, $cfg->{task_folder}, "polish_$id";
        ensure_directory($folder);
        hill_climbing($folder, $prompt, 1, $cfg->{max_iterations}, $cfg->{criteria_file});

        my $result = read_file("$folder/best.txt") // '';
        die "Polish failed for chunk $id\n" unless length $result;
        $polished{$id} = $result;
    }

    my $output = merge_chunks($order_ref, \%polished, "\n\n");
    write_file($cfg->{output_file}, $output) or die "Failed to write polished output\n";
    print "polish-pass complete -> $cfg->{output_file}\n";
}

sub patch_pass {
    my ($config_string) = @_;
    my $cfg = parse_config_string($config_string);
    validate_config($cfg, ['patch_prompt_file', 'input_file', 'review_output_file', 'output_file', 'project_folder', 'task_folder', 'global_id_name', 'list_member_placeholder_name', 'max_iterations']);

    my $template = read_file($cfg->{patch_prompt_file});
    die "Missing patch_prompt_file" unless length $template;
    my $full_text = read_file($cfg->{input_file});
    die "Missing input_file" unless defined $full_text;
    my $reviews = read_file($cfg->{review_output_file});
    die "Missing review_output_file" unless defined $reviews;

    my ($chunks_ref, $order_ref) = burst_output($full_text, $cfg->{global_id_name});

    my %to_fix;
    for my $block (split /\n---\s*\n/, $reviews) {
        next unless $block =~ /^ID:\s*(\S+)/m;
        my $id = uc $1;
        push @{ $to_fix{$id} }, $block;
    }

    for my $id (@$order_ref) {
        next unless exists $to_fix{$id};
        my $raw = $chunks_ref->{$id};
        my $prompt = $template;
        if (my $ph = $cfg->{list_member_placeholder_name}) {
            my $pat = quotemeta('{'.$ph.'}');
            $prompt =~ s/$pat/$raw/g;
        }
        if ($prompt =~ /\{fixes\}/) {
            my $fix_text = join "\n---\n", @{ $to_fix{$id} };
            $prompt =~ s/\{fixes\}/$fix_text/g;
        }

        my $folder = join '/', $cfg->{project_folder}, $cfg->{task_folder}, "patch_$id";
        ensure_directory($folder);
        hill_climbing($folder, $prompt, 1, $cfg->{max_iterations}, $cfg->{criteria_file});
        
        my $result = read_file("$folder/best.txt") // '';
        die "Patch failed for chunk $id" unless length $result;
        $chunks_ref->{$id} = $result;
    }

    my $output = merge_chunks($order_ref, $chunks_ref, "\n\n");
    write_file($cfg->{output_file}, $output) or die "Failed to write patched output\n";
    print "patch-pass complete -> $cfg->{output_file}\n";
}

sub consistency_pass {
    my ($cfg_str) = @_;
    my $cfg = parse_config_string($cfg_str);
    validate_config($cfg, ['consistency_prompt_file', 'input_file', 'output_file', 'project_folder', 'task_folder', 'max_iterations']);

    my $tmpl = read_file($cfg->{consistency_prompt_file});
    my $full = read_file($cfg->{input_file});
    
    # Use non-destructive substitution with /r flag
    my $prompt = $tmpl =~ s/\{text\}/$full/r;
    
    my $folder = "$cfg->{project_folder}/$cfg->{task_folder}/consistency";
    ensure_directory($folder);
    hill_climbing($folder, $prompt, 1, $cfg->{max_iterations}, $cfg->{criteria_file});

    my $out = read_file("$folder/best.txt");
    write_file($cfg->{output_file}, $out);
    print "consistency-pass complete -> $cfg->{output_file}\n";
}

sub validate_pass {
    my ($cfg_str) = @_;
    my $cfg = parse_config_string($cfg_str);
    validate_config($cfg, ['input_file', 'validation_cmd', 'validation_report_file']);

    my $in = $cfg->{input_file};
    my $cmd = "$cfg->{validation_cmd} \"$in\" 2>&1"; # Quote input file for safety
    my $report = `$cmd`;
    
    write_file($cfg->{validation_report_file}, $report);
    print "validate-pass complete -> $cfg->{validation_report_file}\n";
}

sub finalize_pass {
    my ($cfg_str) = @_;
    my $cfg = parse_config_string($cfg_str);
    validate_config($cfg, ['input_file', 'output_file']);

    my $text = read_file($cfg->{input_file});
    
    if (my $gid = $cfg->{global_id_name}) {
        $text =~ s/^\s*\Q$gid\E\s*:\s*\d+\s*\n?//mg;
    }

    if (my $cmd = $cfg->{finalize_cmd}) {
        my $tmp_in = "$cfg->{project_folder}/tmp_finalize_input.txt";
        write_file($tmp_in, $text);
        system("$cmd \"$tmp_in\" \"$cfg->{output_file}\""); # Quote paths
    } else {
        write_file($cfg->{output_file}, $text);
    }
    
    print "finalize-pass complete -> $cfg->{output_file}\n";
}


# --- Pass-Based Pipeline Helper Functions ---

sub parse_config_string {
    my ($text) = @_;
    my %config;
    for my $line (split /\r?\n/, $text) {
        $line = trim($line);
        next if $line eq '' || $line =~ /^#/;
        my ($key, $value) = split /:/, $line, 2;
        $config{trim($key)} = defined $value ? trim($value) : '';
    }
    return \%config;
}

sub validate_config {
    my ($cfg, $required_keys) = @_;
    for my $key (@$required_keys) {
        die "Missing required config key '$key'\n" unless exists $cfg->{$key} && defined $cfg->{$key} && $cfg->{$key} ne '';
    }
    if (exists $cfg->{max_iterations} && ($cfg->{max_iterations} !~ /^\d+$/ || $cfg->{max_iterations} <= 0)) {
        die "Invalid max_iterations: must be a positive integer\n";
    }
}

sub choose_primary_input_path {
    my ($cfg) = @_;
    if ($cfg->{data_type} eq 'list' && $cfg->{list_input_file} && -e $cfg->{list_input_file}) {
        return $cfg->{list_input_file};
    }
    return $cfg->{placeholder_1_file} // '';
}

sub prepare_prompt {
    my ($template, $cfg) = @_;
    my $prompt = $template;
    my @placeholders = (
        ['placeholder_1_name', 'placeholder_1_file'],
        ['placeholder_2_name', 'placeholder_2_file'],
        ['primer', 'primer_file'],
        ['evaluation_criteria', 'criteria_file'],
    );
    foreach my $p (@placeholders) {
        my ($ph_name_key, $ph_file_key) = @$p;
        my $placeholder_name = ($ph_name_key eq 'primer' || $ph_name_key eq 'evaluation_criteria') ? $ph_name_key : $cfg->{$ph_name_key};
        if ($placeholder_name && (my $file = $cfg->{$ph_file_key})) {
            if (-e $file) {
                my $text = read_file($file);
                my $pattern = quotemeta('{' . $placeholder_name . '}');
                $prompt =~ s/$pattern/$text/g;
            }
        }
    }
    return $prompt;
}

sub burst_input {
    my ($text, $cfg) = @_;
    return ($text) if $cfg->{data_type} ne 'list';
    my $marker = $cfg->{list_marker} // 'empty_lines';

    if ($marker eq 'empty_lines') {
        return grep { /\S/ } split /\n{2,}/, $text;
    } elsif ($marker eq 'one_line_per_item') {
        return split /\r?\n/, $text;
    } else {
        my $esc = quotemeta $marker;
        return grep { /\S/ } split /(?=$esc)/i, $text;
    }
}

sub process_chunk {
    my (%args) = @_;
    my ($raw_chunk, $prompt_template, $cfg, $serial) = @args{'raw_chunk', 'prompt_template', 'config', 'serial_number'};
    my $prompt = $prompt_template;
    if (my $ph = $cfg->{list_member_placeholder_name}) {
        my $pat = quotemeta('{' . $ph . '}');
        $prompt =~ s/$pat/$raw_chunk/g;
    }
    my $folder = join '/', $cfg->{project_folder}, $cfg->{task_folder}, "item_$serial";
    ensure_directory($folder);
    hill_climbing($folder, $prompt, $cfg->{judge_count} // 1, $cfg->{max_iterations}, $cfg->{criteria_file});
    return read_file("$folder/best.txt") // '';
}

sub assemble_output {
    my ($results_ref, $raw_ref, $cfg) = @_;
    my @revised = @$results_ref;
    my @raw = @$raw_ref;
    my $out = "";

    for my $i (0 .. $#revised) {
        my $name = $raw[$i] // "";
        my $body = $revised[$i] // "";
        
        my $heading = "";
        if ($cfg->{section_label} && $cfg->{section_label} ne '') {
            (my $heading_item = $name) =~ s/\R.*//s;
            $heading_item = (length($heading_item) > 50) ? substr($heading_item, 0, 50) . '...' : $heading_item;
            $heading = "$cfg->{section_label}: $heading_item\n";
        } elsif ($cfg->{show_item_heading}) {
            (my $heading_item = $name) =~ s/\R.*//s;
            $heading = "$heading_item\n";
        }
        
        $out .= $heading . $body . "\n\n";
    }

    if (my $gid = $cfg->{global_id_name}) {
        if (my $sub_marker = $cfg->{sublist_marker}) {
            (my $base = $sub_marker) =~ s/:$//;
            my $marker_re = qr{^\s*(?i:\Q$base\E):?\s*}m;
            my @chunks = split /(?=$marker_re)/, $out;
            my $n = 1;
            my $new_out = "";
            for my $i (0 .. $#chunks) {
                my $c = $chunks[$i];
                next unless $c =~ /\S/;
                $new_out .= "$gid: $n\n" . $c;
                $new_out .= "\n" if $i < $#chunks;
                $n++;
            }
            $out = $new_out;
        }
    }
    return $out;
}

sub burst_output {
    my ($text, $id_key) = @_;
    my $marker_re = qr/^\s*\Q$id_key\E\s*:\s*(\S+)\s*$/im;
    my @parts = split /(?=^\s*\Q$id_key\E\s*:)/im, $text;
    my (%chunks, @order);
    for my $part (@parts) {
        if ($part =~ $marker_re) {
            my $id = uc $1;
            $part =~ s/^\s*//;
            $chunks{$id} = $part;
            push @order, $id;
        }
    }
    return (\%chunks, \@order);
}

sub merge_chunks {
    my ($order_ref, $chunks_ref, $joiner) = @_;
    my @out;
    for my $id (@$order_ref) {
        push @out, $chunks_ref->{$id};
    }
    return join $joiner, @out;
}


# ==============================================================================
# SECTION 5: OTHER LLM PATTERNS
# ==============================================================================

sub process_accumulation_prompt {
    my ($prompt_template, $max_iterations) = @_;
    $max_iterations ||= 5;
    my $accumulated_response = '';

    for (my $i = 1; $i <= $max_iterations; $i++) {
        my $prompt = $prompt_template;
        my $find = "{accumulated_text}";
        my $replace = $accumulated_response;
        $prompt =~ s/\Q$find\E/$replace/g; # Use \Q for safety

        my $response = call_llm($prompt);
        my $answer = extract_text_between_tags($response, 'answer');
        
        last if $answer eq '';
        
        $accumulated_response .= "\n\n" if $accumulated_response ne '';
        $accumulated_response .= $answer;
    }
    return $accumulated_response;
}

sub extract_list_from_text_old {
    my ($big_text, $extraction_type, $target_description, $chunk_size, $max_loops) = @_;
    $chunk_size ||= 10;
    $extraction_type = ($extraction_type eq 'explicit_list') ? 'explicit_list' : 'organic_orthogonal';
    my @extracted_list;
    my $last_item = '';
    my $all_done = 0;
    my $iterations = 0;
    $max_loops ||= 20;

    while (!$all_done && $iterations++ < $max_loops) {
        my $prompt = build_prompt_old(
            type => $extraction_type, text => $big_text,
            target_description => $target_description, chunk_size => $chunk_size,
            extracted_so_far => \@extracted_list, last_item => $last_item,
        );
        my $response = call_llm($prompt);
        my $answer = extract_text_between_tags($response, 'answer');
        last unless defined $answer && $answer ne '';
        
        my @new_items = split /\n{2,}/, $answer; # Assume multi-line blocks
        @new_items = grep { /\S/ } map { trim($_) } @new_items;
        
        push @extracted_list, @new_items;
        $last_item = $new_items[-1] // $last_item;
    }
    warn "extract_list_from_text: reached $max_loops iterations\n" if $iterations >= $max_loops;
    return join "\n\n", @extracted_list;
}

sub build_prompt_old {
    my %args = @_;
    my $chunks = join "\n\n", @{ $args{extracted_so_far} };
    # ... (implementation omitted for brevity, assumed similar to other build_prompt)
    return "";
}


1; # Required for all Perl library files
